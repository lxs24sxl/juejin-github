export const res = {
  "data":
  {
    "articleFeed":
    {
      "items":
      {
        "edges": [
          {
            "node": { 
              "id": "5d633a33e51d453b397743bb", 
              "commentsCount": 3, 
              "hot": false, 
              "hotIndex": 47.133, 
              "original": true, 
              "originalUrl": "https://juejin.im/post/5d627a4cf265da03963ba43c", 
              "rankIndex": 33.970437926253, 
              "screenshot": "", 
              "content": "时间过得真快，转眼之间 19 年都已经快进入 9 月份了。 今天就来谈谈在这剩余的时间中我们还可以学点什么来充实自己，提高自己的竞争力。 前端基础的重要性我觉得不需要多说了，无论是写出健壮的代码还是定位问题亦或者是面试中都是相当重要的一块内容。 如果你认为自身的前端基础还不过关…", 
              "summaryInfo": null, 
              "category": { 
                "name": "前端", 
                "id": "5562b415e4b00c57d9b94ac8" 
              }, 
              "tags": [
                { 
                  "id": "55964d83e4b08a686cc6b353", 
                  "title": "JavaScript" 
                }
              ], 
              "title": "你在 19 年剩余的时间里还能学点什么？", 
              "type": "post", 
              "user": { 
                "id": "574f8d8d2e958a005fd4edac", 
                "role": "editor", 
                "avatarHd": null, 
                "avatarLarge": "https://user-gold-cdn.xitu.io/2018/10/30/166c3fd3666b5d05?w=200&h=200&f=jpeg&s=8287", 
                "username": "yck" 
              }, 
              "lastCommentTime": "2019-08-26T10:04:05.573Z", 
              "likeCount": 12, 
              "eventInfo": null, 
              "viewerHasLiked": false, 
              "createdAt": "2019-08-26T01:47:31.463Z", 
              "updatedAt": "2019-08-26T02:18:36.040Z" 
            }
          }, { "node": { "id": "5d6333756fb9a06aef08f655", "commentsCount": 2, "hot": false, "hotIndex": 38.8804, "original": true, "originalUrl": "https://juejin.im/post/5d622f14f265da03a1486408", "rankIndex": 18.986692384205, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/25/16cc7a76c11fcdbc?w=550&h=309&f=png&s=259116", "content": "JS通过new来生成对象，但是仅靠构造函数，每次生成的对象都不一样。 当创建一个函数时，JS会自动为函数添加prototype属性，值是一个有constructor的对象。 原因是：People1和People2的原型是People.prototype，答案在下方的：构造函数是…", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "55964d83e4b08a686cc6b353", "title": "JavaScript" }, { "id": "5597a05ae4b08a686ce56f6f", "title": "前端" }], "title": "JS基础-函数、对象和原型、原型链的关系", "type": "post", "user": { "id": "58714f0eb123db4a2eb95372", "role": "editor", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2017/12/22/1607d2bb387d545d?w=1920&h=1080&f=jpeg&s=343675", "username": "OBKoro1" }, "lastCommentTime": "2019-08-26T09:47:08.842Z", "likeCount": 9, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T01:18:45.712Z", "updatedAt": "2019-08-26T02:18:06.539Z" } }, { "node": { "id": "5d6323c4e51d4561cc25f05b", "commentsCount": 13, "hot": false, "hotIndex": 84.0494, "original": true, "originalUrl": "https://juejin.im/post/5d632361e51d4561e224a35c", "rankIndex": 17.788992340229, "screenshot": "", "content": "为了保证的可读性，本文采用意译而非直译。 JS的一些特性极大地改变了咱们的编码方式。从ES6年开始，对咱们代码影响最大的特性的解 、箭头函数、类和模块系统。 到2019年8月，一个新的可选链提案已经进入第三阶段，这是一个很好的改进。可选链接改变了从深层对象结构访问属性的方式。 …", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "55964d83e4b08a686cc6b353", "title": "JavaScript" }, { "id": "5597a13de4b08a686ce58b7e", "title": "ECMAScript 6" }], "title": "JS可选链的好处", "type": "post", "user": { "id": "59df61ec51882578ce26ee6e", "role": "guest", "avatarHd": null, "avatarLarge": "https://mirror-gold-cdn.xitu.io/168e08a02f4dda88289", "username": "前端小智" }, "lastCommentTime": "2019-08-26T10:13:23.766Z", "likeCount": 15, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T00:11:48.548Z", "updatedAt": "2019-08-26T02:17:53.307Z" } }, { "node": { "id": "5d6321966fb9a06aed712d76", "commentsCount": 0, "hot": false, "hotIndex": 17.3243, "original": true, "originalUrl": "https://juejin.im/post/5d5fa22ee51d4561de20b5f5", "rankIndex": 16.727356185569, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/26/16ccb3aae6ea832f?w=1600&h=1080&f=jpeg&s=63888", "content": "在目前的前端领域，单页web应用（SPA）已经有了比较高的占有率，比较主流的web框架React、Angular、Vue几乎已经统治了前端市场。 单页应用确实带来了更好的前后端分离，以及用户体验好、快，内容的改变不需要重新加载整个页面等等的优点，喜忧参半，SPA应用首屏加载慢、…", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "55964d83e4b08a686cc6b353", "title": "JavaScript" }], "title": "使用预渲提升SPA应用体验", "type": "post", "user": { "id": "5a1ba4ef5188255cca52cc7e", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/5/9/16a9b74e286fa00d?w=460&h=460&f=png&s=129217", "username": "臭脚脚" }, "lastCommentTime": null, "likeCount": 9, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T02:00:38.517Z", "updatedAt": "2019-08-26T02:17:55.430Z" } }, { "node": { "id": "5d632e58f265da03ed195d95", "commentsCount": 0, "hot": false, "hotIndex": 10.0784, "original": true, "originalUrl": "https://juejin.im/post/5d629d7b5188252501776d3e", "rankIndex": 14.336267266829, "screenshot": "", "content": "本篇是 JS系列中最重要的一章，花费 3 分钟即可理解，如果你已了解，快速浏览即可。 本篇文章主讲构造函数、原型以及原型链，包括 Symbol 是不是构造函数、constructor 属性是否只读、prototype 、__proto__ 、[[Prototype]] 、原型链…", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "5597a05ae4b08a686ce56f6f", "title": "前端" }], "title": "JS 系列二：原型与原型链", "type": "post", "user": { "id": "5c8f1c6b5188252d65343ff4", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/7/21/16c14d128fb99953?w=256&h=256&f=jpeg&s=17846", "username": "前端瓶子君" }, "lastCommentTime": null, "likeCount": 3, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T02:03:17.095Z", "updatedAt": "2019-08-26T02:18:45.385Z" } }, { "node": { "id": "5d629944f265da03af19de41", "commentsCount": 3, "hot": false, "hotIndex": 19.1888, "original": true, "originalUrl": "https://juejin.im/post/5d6298c75188255625591ae6", "rankIndex": 14.811523321639, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/25/16cc9264d8fa31b1?w=431&h=300&f=jpeg&s=10102", "content": "本文是经典的Functors, Applicatives, And Monads In Pictures的Typescript翻译版本。 Functor/Applicative/Monad是函数式编程中的一些比较‘基础’的概念，反正我是不认同‘基础’这个说法的，笔者也阅读过很多…", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "55964d83e4b08a686cc6b353", "title": "JavaScript" }], "title": "Typescript版图解Functor , Applicative 和 Monad", "type": "post", "user": { "id": "5762733b2e958a00696163ea", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/7/27/16c337574fd88b02?w=640&h=609&f=png&s=227358", "username": "_sx_" }, "lastCommentTime": "2019-08-26T10:17:52.953Z", "likeCount": 9, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T01:41:30.666Z", "updatedAt": "2019-08-26T02:17:59.947Z" } }, { "node": { "id": "5d62559de51d4561c02a254e", "commentsCount": 1, "hot": false, "hotIndex": 13.1166, "original": true, "originalUrl": "https://juejin.im/post/5d62553ee51d4561c41fb849", "rankIndex": 13.312369626897, "screenshot": "", "content": "浏览器中的js，就是ECMAScript语法+Web API。 NodeJs中的js，就是ECMAScript语法+Node API。 上图可以看到，语法都是相同的语法（ECMAScript），只不过所在的环境不同，提供的API不同，能干的事就不一样了。图没有列出所有的API，…", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "555e9a77e4b00c57d9955d64", "title": "Node.js" }], "title": "Node.js 研究", "type": "post", "user": { "id": "5936e1b9a22b9d005808aef0", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/8/4/16c5b9066b944bb2?w=1024&h=1024&f=jpeg&s=342683", "username": "猎户座小陈" }, "lastCommentTime": "2019-08-25T17:41:14.346Z", "likeCount": 7, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T01:56:56.753Z", "updatedAt": "2019-08-26T02:17:55.527Z" } }, { "node": { "id": "5d6327bae51d4561ba48fe01", "commentsCount": 0, "hot": false, "hotIndex": 3.4413, "original": true, "originalUrl": "https://juejin.im/post/5d6325b7e51d453b1f37eb43", "rankIndex": 11.663485422132, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/26/16ccb4c287d773e7?w=640&h=360&f=jpeg&s=28951", "content": "近几年单页应用（SPA）越来越来火，也成为了主流，其中Vue，React，Angular就是典型的代表。将导航的实现放在了客户端去处理，极大提升了用户体验，给人一直类似原生应用的效果。下面我们就简单了解下。 在传统Web应用中，导航是一个页面为单位进行。在地址栏输入路径，页面请…", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "55964d83e4b08a686cc6b353", "title": "JavaScript" }], "title": "SPA中的路由导航", "type": "post", "user": { "id": "599783bcf265da24975fd79f", "role": "guest", "avatarHd": null, "avatarLarge": "https://mirror-gold-cdn.xitu.io/168e087af337f0847ce", "username": "禾寸" }, "lastCommentTime": null, "likeCount": 1, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T02:02:57.716Z", "updatedAt": "2019-08-26T02:17:04.950Z" } }, { "node": { "id": "5d6312315188253a56350088", "commentsCount": 2, "hot": false, "hotIndex": 11.9618, "original": true, "originalUrl": "https://juejin.im/post/5d6310975188256ec01d8418", "rankIndex": 11.282618643329, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/26/16ccaf957459c893?w=1500&h=750&f=png&s=27308", "content": "抽丝剥茧RecyclerView系列文章的目的在于帮助Android开发者提高对RecyclerView的认知，本文是整个系列的第二篇。 LayoutManager是RecyclerView中的重要一环，使用LayoutManager就跟玩捏脸蛋的游戏一样，即使好看的五官(好看…", "summaryInfo": null, "category": { "name": "Android", "id": "5562b410e4b00c57d9b94a92" }, "tags": [{ "id": "5597838ee4b08a686ce2319d", "title": "Android" }], "title": "抽丝剥茧RecyclerView - LayoutManager", "type": "post", "user": { "id": "5c7780e16fb9a049a8200267", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/2/28/16932d0678f2dac1?w=526&h=600&f=jpeg&s=41004", "username": "TeaOf" }, "lastCommentTime": "2019-08-26T10:05:53.773Z", "likeCount": 1, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T01:41:46.730Z", "updatedAt": "2019-08-26T02:16:56.718Z" } }, { "node": { "id": "5d631acd518825052c080448", "commentsCount": 0, "hot": false, "hotIndex": 5.2757, "original": true, "originalUrl": "https://juejin.im/post/5d631a246fb9a06b2e3cff04", "rankIndex": 10.045305314177, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/26/16ccb1fd0ac30acc?w=228&h=221&f=png&s=16489", "content": "也就是说如果你有过使用 Canvas 的开发经验你就可以来封装自己的组件。 下面我以一个进度环为例，来探究一下如何使用ht.js封装出一个拓扑组件。 ht.Default.setImage('circle-progress-bar', { width: 100, height:…", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "555eadbbe4b00c57d99623cc", "title": "HTML" }], "title": "基于 HTML5 Canvas 的拓扑组件开发", "type": "post", "user": { "id": "5c7e9f83e51d4575d911141b", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/3/6/1694ea13e87741f9?w=819&h=819&f=jpeg&s=349871", "username": "勤劳的搬运工" }, "lastCommentTime": null, "likeCount": 2, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T02:00:28.531Z", "updatedAt": "2019-08-26T02:17:00.984Z" } }, { "node": { "id": "5d632c7f6fb9a06aea619f4e", "commentsCount": 0, "hot": false, "hotIndex": 33.056, "original": false, "originalUrl": "https://www.jianshu.com/p/cc4cb0e0b1db", "rankIndex": 9.4280602000977, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/26/16ccb65ce5166f6d?w=410&h=222&f=png&s=14683", "content": "今天，我将 手把手教大家实现自适应的心跳保活机制，从而能高效维持长连接 示意图 示意图 通过 长时间保持双方连接", "summaryInfo": null, "category": { "name": "Android", "id": "5562b410e4b00c57d9b94a92" }, "tags": [{ "id": "5597838ee4b08a686ce2319d", "title": "Android" }, { "id": "559a7207e4b08a686d25703e", "title": "Java" }], "title": "如何高效维持网络长连接：手把手教你实现 自适应的心跳保活机制", "type": "article", "user": { "id": "58d4d9781b69e6006ba65edc", "role": "editor", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/4/13/16a145ebc036d461?w=1756&h=1756&f=png&s=180508", "username": "Carson_Ho" }, "lastCommentTime": null, "likeCount": 14, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T00:49:03.270Z", "updatedAt": "2019-08-26T02:17:03.467Z" } }, { "node": { "id": "5d6323b3518825776118afc8", "commentsCount": 1, "hot": false, "hotIndex": 9.3618, "original": true, "originalUrl": "https://juejin.im/post/5d6281b15188252501776d27", "rankIndex": 8.4019135956161, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/26/16ccb430ae967c95?w=1332&h=732&f=jpeg&s=86008", "content": "JavaScript中使用IEEE-754 64位存储。位操作符不能直接操作64位的值，而是将它转换为二进制补码形式的32位的整数，最后再将结果转为64位。32位中31位表示整数的值，第32位为符号位（0为正数，1为负数）。每一位由二进制数存储，31位中的每一位的索引表示2的次…", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "55964d83e4b08a686cc6b353", "title": "JavaScript" }], "title": "JavaScript中的位操作符", "type": "post", "user": { "id": "5971a626f265da6c50303ae2", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/8/22/16cb93dccdea3d48?w=808&h=951&f=png&s=1064026", "username": "赛博朋克的杰洛特" }, "lastCommentTime": "2019-08-26T10:16:47.721Z", "likeCount": 3, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T01:39:48.862Z", "updatedAt": "2019-08-26T02:18:45.416Z" } }, { "node": { "id": "5d6266c0e51d453b72147649", "commentsCount": 0, "hot": false, "hotIndex": 1.0193, "original": true, "originalUrl": "https://juejin.im/post/5d6266a6e51d4561cd246659", "rankIndex": 8.3943758459278, "screenshot": "", "content": "如果您已经看过我的Becoming a Master Window Fitter谈话，您就会知道处理窗口插件可能很复杂。 最近，我一直在改进几个应用程序中的系统栏处理，使他们能够在状态和导航栏后面绘制。 我想我已经提出了一些方法，可以使处理插入更容易(希望如此)。原文 对于本文…", "summaryInfo": null, "category": { "name": "Android", "id": "5562b410e4b00c57d9b94a92" }, "tags": [{ "id": "5597838ee4b08a686ce2319d", "title": "Android" }], "title": "WindowInsets  - 布局的监听器", "type": "post", "user": { "id": "57621a722e958a00695e67d1", "role": "guest", "avatarHd": null, "avatarLarge": "https://mirror-gold-cdn.xitu.io/168e082b9c395ee34c3", "username": "easyhappy" }, "lastCommentTime": null, "likeCount": 0, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T02:08:31.292Z", "updatedAt": "2019-08-26T02:17:31.728Z" } }, { "node": { "id": "5d6291266fb9a06b122f47cc", "commentsCount": 0, "hot": false, "hotIndex": 1.668, "original": true, "originalUrl": "https://juejin.im/post/5d6291036fb9a06acf2b665a", "rankIndex": 6.9595153777452, "screenshot": "", "content": "单例模式是设计模式中最简单也是最常用的设计模式之一，单例顾名思义就是系统中只有唯一实例，这个唯一实例的获取方式就是通过一个方法的调用获得，而不是通过正常流程中的new实例化。多年前在学习设计模式时就了解到单例有多种实现方式，今天就来总结一下，并且探索一下在当前java生态框架中…", "summaryInfo": null, "category": { "name": "后端", "id": "5562b419e4b00c57d9b94ae2" }, "tags": [{ "id": "55a872f0e4b05881ac919dfc", "title": "设计模式" }], "title": "聊一聊单例及框架中的单例", "type": "post", "user": { "id": "5c07ee646fb9a049c643a2d1", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/7/8/16bd19bbb61f2671?w=200&h=200&f=jpeg&s=16002", "username": "呼呼虎" }, "lastCommentTime": null, "likeCount": 1, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T02:16:10.959Z", "updatedAt": "2019-08-26T02:17:54.476Z" } }, { "node": { "id": "5d6332e36fb9a06ad347369f", "commentsCount": 0, "hot": false, "hotIndex": 2.3559, "original": true, "originalUrl": "https://juejin.im/post/5d63311be51d45620821ced8", "rankIndex": 6.8900394171613, "screenshot": "", "content": "react凭借virtual DOM和diff算法拥有高效的性能，除此之外也有很多其他的方法和技巧可以进一步提升react性能，在本文中我将列举出可有效提升react性能的几种方法，帮助我们改进react代码，提升性能。但是我们不必一定要在项目中使用这些方法，但是我们有必要知道…", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "555e99ffe4b00c57d99556aa", "title": "React.js" }], "title": "React性能优化的8种方式了解一下？", "type": "post", "user": { "id": "5a16e7076fb9a0452577cad4", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/8/1/16c4cf8ae57c447e?w=500&h=312&f=jpeg&s=8912", "username": "Rashomon" }, "lastCommentTime": null, "likeCount": 1, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T02:03:49.673Z", "updatedAt": "2019-08-26T02:17:53.061Z" } }, { "node": { "id": "5d6324cee51d4561e5353959", "commentsCount": 0, "hot": false, "hotIndex": 2.462, "original": true, "originalUrl": "https://juejin.im/post/5d5f8bb5f265da03d42fadce", "rankIndex": 6.3510338397713, "screenshot": "", "content": "离上篇文章介绍OpenGit_Flutter已经过了两个月，在两个月期间完成了v1.1.0、v1.2.0以及下文马上介绍的v1.3.0版本，点击见版本更新记录。在v1.3.0版本中，对整体UI做了修改，采用卡片式风格；对登录界面做了改版，UI主要参考flutter-ui-nic…", "summaryInfo": null, "category": { "name": "Android", "id": "5562b410e4b00c57d9b94a92" }, "tags": [{ "id": "5a96291f6fb9a0535b535438", "title": "Flutter" }], "title": "使用Flutter开发的一款仿Gitme的客户端", "type": "post", "user": { "id": "56ea9d7ca341310054a57b7c", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/4/30/16a6d0a13eb40f4e?w=1242&h=1227&f=png&s=722972", "username": "Yuzo" }, "lastCommentTime": null, "likeCount": 0, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T02:02:39.833Z", "updatedAt": "2019-08-26T02:17:53.169Z" } }, { "node": { "id": "5d625f5a6fb9a06b09362529", "commentsCount": 0, "hot": false, "hotIndex": 3.1506, "original": true, "originalUrl": "https://juejin.im/post/5d625e496fb9a06ada54bcb3", "rankIndex": 6.111323662709, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/25/16cc84318f6a5fde?w=600&h=600&f=jpeg&s=13829", "content": "答案是：代码段1打印的是1，代码段2打印的是 a() 函数。 为什么会这样呢？这就涉及到js中的变量提升和函数提升的具体过程了。 所以 js 引擎并不是在我们定义一个变量的时候，声明完成之后立即赋值，而是把所有用到的变量全部声明之后，再到变量的定义的地方进行赋值，变量的声明的过…", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "55964d83e4b08a686cc6b353", "title": "JavaScript" }], "title": "JavaScript变量与函数提升过程详解", "type": "post", "user": { "id": "5bd91b5f5188257f5d1aefe4", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/3/18/16990ef83703eaa8?w=1242&h=1242&f=png&s=1222593", "username": "Daotin" }, "lastCommentTime": null, "likeCount": 1, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T01:50:58.073Z", "updatedAt": "2019-08-26T02:17:15.758Z" } }, { "node": { "id": "5d6337a6518825790e6b66db", "commentsCount": 1, "hot": false, "hotIndex": 8.3035, "original": true, "originalUrl": "https://juejin.im/post/5d2178ede51d4556d86c7b36", "rankIndex": 5.5508071386581, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/26/16cc98e021bdde77?w=1299&h=728&f=webp&s=6956", "content": "Flutter自从1.0版本发布，现在越来越受欢迎，很多公司都在研究或者用在项目上。今天实践一下Android原生项目如何嵌套Flutter页面，具体原理就是Flutter作为Android Module出现在项目中，这样就可以在已有的项目中使用，Android项目也是一个工程…", "summaryInfo": null, "category": { "name": "Android", "id": "5562b410e4b00c57d9b94a92" }, "tags": [{ "id": "5a96291f6fb9a0535b535438", "title": "Flutter" }], "title": "Android 混合Flutter之源码集成方式", "type": "post", "user": { "id": "597247ad5188255aed1fbba6", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/5/31/16b0cef0ee136f7c?w=957&h=957&f=jpeg&s=119442", "username": "真丶深红骑士" }, "lastCommentTime": "2019-08-26T09:43:56.720Z", "likeCount": 3, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T01:39:42.469Z", "updatedAt": "2019-08-26T02:17:12.161Z" } }, { "node": { "id": "5d632c296fb9a06afc254d58", "commentsCount": 0, "hot": false, "hotIndex": 16.4848, "original": false, "originalUrl": "https://blog.csdn.net/carson_ho/article/details/100070713", "rankIndex": 5.061401161536, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/26/16ccb64808db7654?w=304&h=164&f=png&s=8557", "content": "今天，我将全面介绍Android开发中主流的技术框架MVC、MVP 与 MVVM模式，并实例讲解MVP模式，希望您们会喜欢", "summaryInfo": null, "category": { "name": "Android", "id": "5562b410e4b00c57d9b94a92" }, "tags": [{ "id": "55cdb52740ac79db3570607f", "title": "架构" }, { "id": "5597a035e4b08a686ce56bd9", "title": "设计" }], "title": "这是一份全面 & 清晰的架构设计指南：MVC、MVP & MVVM模式（含实例讲解）", "type": "article", "user": { "id": "58d4d9781b69e6006ba65edc", "role": "editor", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/4/13/16a145ebc036d461?w=1756&h=1756&f=png&s=180508", "username": "Carson_Ho" }, "lastCommentTime": null, "likeCount": 5, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T00:47:37.764Z", "updatedAt": "2019-08-26T02:17:21.043Z" } }, { "node": { "id": "5d624d615188256dad1133f4", "commentsCount": 0, "hot": false, "hotIndex": 4.4353, "original": true, "originalUrl": "https://juejin.im/post/5d615b7f6fb9a06b0202ccb5", "rankIndex": 4.5119356946373, "screenshot": "https://user-gold-cdn.xitu.io/2019/8/25/16cc7fe02c35c5fc?w=640&h=300&f=jpeg&s=19317", "content": "1. ES5 继承 代码中，构造函数 B 继承构造函数 A，首先让构造函数 B 的 prototype 对象中的 __proto__ 属性指向构造函数 A 的 prototype 对象，并且将构造函数 B 的 prototype 对象的 constructor 属性赋值为构造函…", "summaryInfo": null, "category": { "name": "前端", "id": "5562b415e4b00c57d9b94ac8" }, "tags": [{ "id": "55964d83e4b08a686cc6b353", "title": "JavaScript" }], "title": "ES6 与 ES5 继承的区别", "type": "post", "user": { "id": "5d57bd39e51d45620c1c53b2", "role": "guest", "avatarHd": null, "avatarLarge": "https://user-gold-cdn.xitu.io/2019/8/17/16c9f7379f9ead73?w=499&h=341&f=jpeg&s=44654", "username": "奔跑吧_兄弟" }, "lastCommentTime": null, "likeCount": 2, "eventInfo": null, "viewerHasLiked": false, "createdAt": "2019-08-26T01:52:12.284Z", "updatedAt": "2019-08-26T02:17:06.493Z" } }], "pageInfo": { "hasNextPage": true, "endCursor": "4.51193569463729993" }
      }
    }
  }
}
